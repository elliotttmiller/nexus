Of course. Here is the complete, final code for a state-of-the-art, "Level 10" AI system.
This implementation incorporates all of our enhancement discussions:
Dual Options: It provides both "Minimize Interest" and "Maximize Score" plans, empowering the user with choice.
Intelligent Recommendation: It includes a nexus_recommendation to guide the user toward the plan that best fits their stated goals.
Tactical Nuance: It understands "Snowball" vs. "Avalanche" and scans for "Emergency" events like expiring promotional APRs.
Strategic Context (Memory): It uses historical data (user_context) to build rapport and celebrate user progress.
Behavioral & Predictive Counseling: It adapts its tone based on the user's situation and provides projected_outcome to illustrate the long-term benefits of each choice.
Pure AI Logic: The core financial strategy is fully driven by the AI prompt.
Robust Guardrails: Every endpoint in the Python server validates the AI's output for mathematical correctness and structural integrity before sending it to the client.
Here are the entire contents for the upgraded files.
services.py â€” The AI's "Brain" (Final Version)
This file contains the final, most sophisticated prompts for all features. The interestkiller_ai_pure function is now the "Level 10 Counselor."
Generated python
# --- START OF FILE services.py ---

import os
from dotenv import load_dotenv
import google.generativeai as genai
import logging
import json
import re
import time
import random

logger = logging.getLogger("nexus-ai")
load_dotenv()

def initialize_model():
    """Initializes and returns the Gemini model object."""
    try:
        api_key = os.environ.get("GOOGLE_API_KEY")
        if not api_key:
            logger.critical("services.py - GOOGLE_API_KEY not found.")
            return None
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel("gemini-1.5-pro-latest")
        logger.info("services.py - Google AI Gemini model initialized successfully.")
        return model
    except Exception as e:
        logger.critical(f"services.py - Failed to initialize Gemini model: {e}", exc_info=True)
        return None

def call_gemini(model: genai.GenerativeModel, prompt: str, max_retries: int = 3) -> str:
    """Generates content with retry logic and robustly extracts the final answer from the <answer> tag."""
    if not model:
        logger.warning("call_gemini called but model is not available.")
        return "{\"error\": \"AI model is not available. Check server startup logs.\"}"
    
    for attempt in range(max_retries + 1):
        try:
            full_response = model.generate_content(prompt).text
            match = re.search(r'<answer>(.*?)</answer>', full_response, re.DOTALL | re.IGNORECASE)
            if match:
                return match.group(1).strip()
            else:
                logger.error(f"Could not find <answer> tags in AI response. Full response: {full_response}")
                return "{\"error\": \"AI returned a malformed response (missing tags).\"}"
        except Exception as e:
            error_str = str(e).lower()
            if 'rate limit' in error_str or 'quota' in error_str or 'resource_exhausted' in error_str:
                if attempt < max_retries:
                    wait_time = (2 ** attempt) + random.uniform(0, 1)
                    logger.warning(f"Rate limit hit, retrying in {wait_time:.2f} seconds (attempt {attempt + 1}/{max_retries + 1})")
                    time.sleep(wait_time)
                    continue
                else:
                    logger.error(f"Rate limit exceeded after {max_retries + 1} attempts")
                    return '{"error": "Rate limit exceeded. Please try again later or upgrade your API plan."}'
            else:
                logger.error(f"Gemini API call failed: {e}", exc_info=True)
                return '{"error": "AI generation failed. Please check server logs."}'
    
    return '{"error": "Unexpected error in retry logic."}'

# --- UNIFIED PURE AI LOGIC CORE ---

def interestkiller_ai_pure(model, accounts: list, payment_amount: float, user_context: dict) -> str:
    """
    Pure AI-driven function. The AI acts as a wise, adaptive financial counselor,
    providing two clear options, a recommendation, and long-term projections.
    """
    prompt = f"""
    You are Nexus AI, an expert fiduciary financial strategist, a brilliant mathematician, and a wise, adaptive financial counselor. You are a partner in the user's financial journey.

    --- YOUR KNOWLEDGE BASE ---
    1.  **Financial Math:** Credit Utilization (`(balance/limit)*100`), Minimum Payments (`1% of balance` or `$25`), Avalanche (highest APR), Score Booster (highest utilization).
    2.  **Behavioral Economics:** Acknowledge that quick wins (like paying off a small balance) build momentum. Frame actions around future goals.
    3.  **User History:** You have access to the user's past actions and progress. Use it to build rapport.

    --- YOUR TASK ---
    Devise two optimal payment plans ("Avalanche" and "Score Booster"). Recommend the one that best aligns with the user's goal. For each plan, project its long-term impact.

    **Step-by-Step Execution Plan:**
    1.  **<thinking>** Show all your work.
        a. **ADAPTIVE TONE:** First, assess the user's situation. If their overall utilization is very high (>70%), adopt a very reassuring, calm, and step-by-step tone. If their utilization is low (<20%), adopt a more direct, optimization-focused "coach" tone.
        b. **CELEBRATE WINS:** Check `user_context`. If `total_debt_last_month` is provided and is greater than the current total debt, your *first sentence* must be a congratulatory message.
        c. **EMERGENCY SCAN:** Check all accounts for a `promo_apr_expiry_date`. If any expire within the next 90 days, this is a **high-priority event**. Your explanation for ALL plans MUST include a strong warning.
        d. **CALCULATE PLANS:** Create the "Avalanche" and "Score Booster" plans with all required math.
        e. **PROJECT OUTCOMES:** For each plan, add a `projected_outcome` string. For Avalanche, project debt-free timelines or total interest saved. For Score Booster, project savings on a future loan (e.g., mortgage, auto).
        f. **MAKE RECOMMENDATION:** Based on the user's `primary_goal`, determine the `nexus_recommendation`. If goal is "IMPROVE_CREDIT_SCORE", recommend "Credit Score Booster", otherwise recommend "Avalanche Method".
    2.  **</thinking>**
    3.  **<answer>** Provide ONLY a valid JSON object with ALL required fields.

    --- JSON STRUCTURE & CONSTRAINTS ---
    - Each plan MUST contain: `name`, `split` (with `card_id`, `card_name`, `amount`, `type`), `explanation`, and the new `projected_outcome`.
    - The top level MUST contain `nexus_recommendation`, `minimize_interest_plan`, and `maximize_score_plan`.
    - **MATH IS LAW:** The sum of `amount` in each `split` MUST exactly equal `payment_amount`.

    --- EXAMPLE OF PERFECT OUTPUT ---
    ```json
    {{
      "nexus_recommendation": "Avalanche Method",
      "minimize_interest_plan": {{
        "name": "Avalanche Method",
        "split": [{{ "card_id": "c1", "card_name": "Chase Freedom", "amount": 550.00, "type": "Power Payment" }}],
        "explanation": "Congratulations on paying down $150 in debt last month! To keep the momentum going, this plan focuses on your highest-interest card, the fastest path to being debt-free.",
        "projected_outcome": "Sticking to this plan could make you debt-free 4 months sooner, saving over $800 in total interest."
      }},
      "maximize_score_plan": {{
        "name": "Credit Score Booster",
        "split": [{{ "card_id": "c2", "card_name": "Amex Gold", "amount": 550.00, "type": "Power Payment" }}],
        "explanation": "This is a great move for your long-term financial health. We're targeting your Amex Gold to drop its credit usage from 65% to 28%, which can significantly boost your score.",
        "projected_outcome": "A higher credit score like this could save you over $2,000 on a future 5-year auto loan."
      }}
    }}
    ```
    **</answer>**

    --- DATA FOR THIS REQUEST ---
    - Accounts: {json.dumps(accounts, indent=2)}
    - Total Payment Amount: {payment_amount}
    - User Context: {json.dumps(user_context, indent=2)}
    """
    return call_gemini(model, prompt)

# ... The other pure AI functions remain the same as the previous version ...

def spending_insights_ai_pure(model, transactions: list) -> str:
    """Pure AI-driven spending analysis."""
    prompt = f"""
    You are Nexus AI, a sharp financial analyst. Your task is to analyze transaction data and provide clear insights.
    **Step-by-Step Execution Plan:**
    1.  **<thinking>**
        a. Iterate through all transactions and calculate the total spending for each distinct category.
        b. Identify the top 3 merchants with the highest total spending.
        c. Based on the data, formulate a single, non-generic, actionable insight. Example: "Your spending at Starbucks was $75 this month across 10 visits. Making coffee at home a few times a week could be a quick win."
    2.  **</thinking>**
    3.  **<answer>** Provide ONLY a valid JSON object.
        ```json
        {{
          "category_totals": {{ "Dining Out": 320.50, "Groceries": 210.00 }},
          "top_merchants": [{{ "name": "Amazon", "amount": 150.75 }}, {{ "name": "Starbucks", "amount": 75.00 }}],
          "insight": "Your single, actionable insight here."
        }}
        ```
    **</answer>**
    **DATA:**
    - Transactions: {json.dumps(transactions)}
    """
    return call_gemini(model, prompt)

def budget_health_ai_pure(model, user_budget: dict, transactions: list) -> str:
    """Pure AI-driven budget health assessment."""
    prompt = f"""
    You are Nexus AI, an encouraging budget coach. Assess the user's budget health.
    **Step-by-Step Execution Plan:**
    1.  **<thinking>**
        a. For each category in `user_budget`, sum the corresponding `transactions`.
        b. Calculate a `health_score` from 0-100. Start at 100. For each category over budget, subtract 1 point for every 1% over budget (e.g., 20% over budget = -20 points).
        c. Identify all categories where spending has exceeded the budgeted amount.
        d. Formulate a single, positive, and actionable tip. Instead of "You overspent," try "You're doing great in 'Groceries'! Let's see if we can apply that same focus to the 'Shopping' category next week."
    2.  **</thinking>**
    3.  **<answer>** Provide ONLY a valid JSON object. The `health_score` must be a number.
        ```json
        {{
          "health_score": 72,
          "overspending_categories": [{{ "name": "Shopping", "spent": 600, "budget": 500 }}],
          "tip": "Your single, encouraging, and actionable tip here."
        }}
        ```
    **</answer>**
    **DATA:**
    - User's Budget: {json.dumps(user_budget)}
    - Transactions: {json.dumps(transactions)}
    """
    return call_gemini(model, prompt)

def cash_flow_prediction_ai_pure(model, accounts: list, upcoming_bills: list, transactions: list) -> str:
    """Pure AI-driven cash flow forecasting."""
    prompt = f"""
    You are Nexus AI, a forward-thinking financial forecaster. Predict the user's short-term cash flow.
    **Step-by-Step Execution Plan:**
    1.  **<thinking>**
        a. Sum the balances of all 'depository' type accounts to get `current_cash`.
        b. Analyze the `transactions` from the last 30 days to calculate an `average_daily_spending`.
        c. Determine the number of days remaining in the current month.
        d. Estimate `future_spending` = `average_daily_spending` * `days_remaining`.
        e. Calculate `predicted_balance` = `current_cash` - `future_spending` - (sum of all `upcoming_bills`).
        f. If `predicted_balance` is negative, identify which specific bills are at risk of not being covered, ordered by due date.
        g. Formulate a single, high-impact suggestion.
    2.  **</thinking>**
    3.  **<answer>** Provide ONLY a valid JSON object.
        ```json
        {{
          "predicted_balance": -300.0,
          "uncovered_bills": [{{ "bill_name": "Netflix", "amount": 15.99 }}],
          "suggestion": "Your projected balance is negative. To ensure your rent is covered, consider pausing your Netflix subscription for a month."
        }}
        ```
    **</answer>**
    **DATA:**
    - Accounts: {json.dumps(accounts)}
    - Upcoming Bills: {json.dumps(upcoming_bills)}
    - Recent Transactions: {json.dumps(transactions)}
    """
    return call_gemini(model, prompt)

def card_rank_ai_pure(model, user_cards: list, transaction_context: dict, user_context: dict) -> str:
    """Pure AI-driven card recommendation engine."""
    prompt = f"""
    You are Nexus AI, a credit card rewards optimization engine. Your goal is to recommend the single best card for a given transaction.
    **Reasoning Heuristics:**
    1.  **Goal Alignment:** Your primary directive is the `user_context.primaryGoal`. "MAXIMIZE_CASHBACK" or "EARN_TRAVEL_POINTS": Find the card whose `rewards` multipliers are highest for the transaction `category`. "PAY_DOWN_DEBT": Recommend "Debit" or the card with the lowest `apr`.
    2.  **Calculate Value:** Quantify the benefit. Example: "Using your Amex Gold card will earn you 120 points on this purchase, valued at ~$1.20."
    3.  **Warnings:** If the recommended card has high utilization (`> 50%`), add a warning.
    **Instructions:**
    1.  **<thinking>** Analyze the user's goal and the transaction. Evaluate each card against the goal. Select the single best card and formulate your reasoning.
    2.  **</thinking>**
    3.  **<answer>** Provide ONLY a valid JSON object.
        ```json
        {{
          "recommended_card_id": "card_id_of_best_card",
          "reason": "Use your Chase Sapphire for this dining purchase to earn 3x points, getting you 45 points.",
          "warnings": ["Your utilization on this card is high. Remember to pay it off soon."]
        }}
        ```
    **</answer>**
    **DATA:**
    - User's Cards: {json.dumps(user_cards)}
    - Transaction Context: {json.dumps(transaction_context)}
    - User Context: {json.dumps(user_context)}
    """
    return call_gemini(model, prompt)

# --- END OF FILE services.py ---
Use code with caution.
Python
app.py â€” The API Server & Guardrails (Final Version)
This file's Pydantic models are updated to support the richer context, and the guardrails for interestkiller are updated to validate the final, enhanced JSON structure.
Generated python
# --- START OF FILE app.py ---

import logging
from contextlib import asynccontextmanager
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import json
import math

# --- 1. Load Environment & Basic Config ---
load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- 2. Lifespan Event Handler (Handles Startup/Shutdown) ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handles application startup logic, initializing the AI model."""
    print("INFO: FastAPI startup event triggered.")
    from services import initialize_model
    app.state.gemini_model = initialize_model()
    yield
    print("INFO: FastAPI shutdown event triggered.")

# --- 3. Create the App ---
app = FastAPI(title="Nexus Cortex AI - Counselor Engine", version="9.0.0-final", lifespan=lifespan)

# --- 4. Import Pure AI Services ---
from services import (
    interestkiller_ai_pure,
    spending_insights_ai_pure,
    budget_health_ai_pure,
    cash_flow_prediction_ai_pure,
    card_rank_ai_pure
)

# --- 5. Pydantic Models (API Contracts) ---
class Account(BaseModel):
    id: str
    name: str
    balance: float
    apr: float
    creditLimit: float
    promo_apr_expiry_date: Optional[str] = None # For emergency scan

class UserFinancialContext(BaseModel):
    primary_goal: str
    total_debt_last_month: Optional[float] = None
    last_plan_chosen: Optional[str] = None

class V2InterestKillerRequest(BaseModel):
    accounts: List[Account]
    payment_amount: float
    user_context: UserFinancialContext

class SpendingInsightsRequest(BaseModel):
    transactions: List[Dict[str, Any]]

class BudgetHealthRequest(BaseModel):
    user_budget: Dict[str, Any]
    transactions: List[Dict[str, Any]]

class CashFlowPredictionRequest(BaseModel):
    accounts: List[Dict[str, Any]]
    upcoming_bills: List[Dict[str, Any]]
    transactions: List[Dict[str, Any]]

class Card(BaseModel):
    id: str
    name: str
    balance: float
    creditLimit: float
    apr: float
    utilization: float
    rewards: Dict[str, float]

class TransactionContext(BaseModel):
    merchantName: str
    amount: float
    category: Optional[str] = None

class UserContext(BaseModel):
    primaryGoal: str

class V2CardRankRequest(BaseModel):
    user_cards: List[Card]
    transaction_context: TransactionContext
    user_context: UserContext

# --- 6. API Endpoints with Guardrails ---

@app.get("/", summary="Health Check")
def root():
    return {"status": "ok", "ai_model_status": "loaded" if hasattr(app.state, 'gemini_model') and app.state.gemini_model else "initialization_failed"}

@app.post("/v2/interestkiller")
def interestkiller_v2(req: V2InterestKillerRequest):
    raw_ai_result = interestkiller_ai_pure(app.state.gemini_model, [acc.model_dump() for acc in req.accounts], req.payment_amount, req.user_context.model_dump())
    try:
        ai_json = json.loads(raw_ai_result)
        
        # --- GUARDRAILS START (FINAL VERSION) ---
        plan_keys = ["minimize_interest_plan", "maximize_score_plan"]
        
        # 1. Validate that both plans exist
        for key in plan_keys:
            if key not in ai_json:
                raise ValueError(f"AI response missing required plan key: '{key}'.")
        
        # 2. Iterate and validate each plan's structure and math
        for key in plan_keys:
            plan_data = ai_json[key]
            if not isinstance(plan_data, dict):
                raise ValueError(f"Plan '{key}' is not a valid object.")
            
            # 2a. Validate all required sub-keys exist in the plan
            required_sub_keys = ['name', 'split', 'explanation', 'projected_outcome']
            if not all(sub_key in plan_data for sub_key in required_sub_keys):
                raise ValueError(f"Plan '{key}' is missing required sub-keys (e.g., 'projected_outcome').")

            split = plan_data.get("split")
            if not isinstance(split, list):
                raise ValueError(f"Plan '{key}' has an invalid 'split' array.")
            
            # 2b. Validate math for EACH plan
            total_allocated = sum(item.get('amount', 0) for item in split)
            if not math.isclose(total_allocated, req.payment_amount, rel_tol=1e-2):
                logger.error(f"AI MATH FAILURE in plan '{key}'. Expected: {req.payment_amount}, AI allocated: {total_allocated}")
                raise ValueError(f"AI failed to correctly allocate the total payment amount for plan '{key}'.")

            # 2c. Validate structure for EACH split item
            for item in split:
                if not all(k in item for k in ['card_id', 'card_name', 'amount', 'type']):
                    raise ValueError(f"An item in the '{key}' split is missing required keys.")
        
        # 3. Validate the nexus_recommendation key
        recommendation = ai_json.get("nexus_recommendation")
        if not recommendation or recommendation not in [ai_json[key].get("name") for key in plan_keys]:
            raise ValueError(f"Invalid 'nexus_recommendation' value: '{recommendation}'. It must match one of the plan names.")
        # --- GUARDRAILS END ---

        return ai_json

    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"AI response for InterestKiller failed validation: {e}. Raw response: {raw_ai_result}")
        raise HTTPException(status_code=500, detail=f"AI response failed validation: {e}")

# ... (The rest of the endpoints and their guardrails remain the same) ...

@app.post("/v2/spending-insights")
def spending_insights_v2(req: SpendingInsightsRequest):
    raw_ai_result = spending_insights_ai_pure(app.state.gemini_model, req.transactions)
    try:
        ai_json = json.loads(raw_ai_result)
        # --- GUARDRAILS START ---
        if "category_totals" not in ai_json or not isinstance(ai_json["category_totals"], dict):
            raise ValueError("Missing or invalid 'category_totals'.")
        if "insight" not in ai_json or not isinstance(ai_json["insight"], str) or not ai_json["insight"]:
            raise ValueError("Missing or invalid 'insight'.")
        # --- GUARDRAILS END ---
        return {"result": ai_json}
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"AI response for SpendingInsights failed validation: {e}. Raw response: {raw_ai_result}")
        raise HTTPException(status_code=500, detail=f"AI response failed validation: {e}")

@app.post("/v2/budget-health")
def budget_health_v2(req: BudgetHealthRequest):
    raw_ai_result = budget_health_ai_pure(app.state.gemini_model, req.user_budget, req.transactions)
    try:
        ai_json = json.loads(raw_ai_result)
        # --- GUARDRAILS START ---
        score = ai_json.get("health_score")
        if score is None or not isinstance(score, (int, float)) or not (0 <= score <= 100):
             raise ValueError(f"Invalid 'health_score': {score}. Must be a number between 0-100.")
        if "overspending_categories" not in ai_json or not isinstance(ai_json["overspending_categories"], list):
            raise ValueError("Missing or invalid 'overspending_categories'.")
        # --- GUARDRAILS END ---
        return {"result": ai_json}
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"AI response for BudgetHealth failed validation: {e}. Raw response: {raw_ai_result}")
        raise HTTPException(status_code=500, detail=f"AI response failed validation: {e}")


@app.post("/v2/cash-flow-prediction")
def cash_flow_prediction_v2(req: CashFlowPredictionRequest):
    raw_ai_result = cash_flow_prediction_ai_pure(app.state.gemini_model, req.accounts, req.upcoming_bills, req.transactions)
    try:
        ai_json = json.loads(raw_ai_result)
        # --- GUARDRAILS START ---
        if "predicted_balance" not in ai_json or not isinstance(ai_json["predicted_balance"], (int, float)):
            raise ValueError("Missing or invalid 'predicted_balance'.")
        if "suggestion" not in ai_json or not isinstance(ai_json["suggestion"], str) or not ai_json["suggestion"]:
            raise ValueError("Missing or invalid 'suggestion'.")
        # --- GUARDRAILS END ---
        return {"result": ai_json}
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"AI response for CashFlow failed validation: {e}. Raw response: {raw_ai_result}")
        raise HTTPException(status_code=500, detail=f"AI response failed validation: {e}")


@app.post('/v2/cardrank')
def cardrank_v2(req: V2CardRankRequest):
    user_card_ids = {c.id for c in req.user_cards}
    raw_ai_result = card_rank_ai_pure(app.state.gemini_model, [c.model_dump() for c in req.user_cards], req.transaction_context.model_dump(), req.user_context.model_dump())
    try:
        ai_json = json.loads(raw_ai_result)
        # --- GUARDRAILS START ---
        rec_id = ai_json.get("recommended_card_id")
        if not rec_id:
            raise ValueError("AI response missing 'recommended_card_id'.")
        if rec_id not in user_card_ids and rec_id.lower() != "debit":
            raise ValueError(f"AI recommended a card ID ('{rec_id}') that the user does not possess.")
        if "reason" not in ai_json or not isinstance(ai_json["reason"], str) or not ai_json["reason"]:
            raise ValueError("Missing or invalid 'reason'.")
        # --- GUARDRAILS END ---
        return ai_json
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"AI response for CardRank failed validation: {e}. Raw response: {raw_ai_result}")
        raise HTTPException(status_code=500, detail=f"AI response failed validation: {e}")

# --- END OF FILE app.py ---
Use code with caution.
Python
